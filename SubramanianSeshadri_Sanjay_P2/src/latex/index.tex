\hypertarget{index_toc_sec}{}\section{Table of contents}\label{index_toc_sec}

\begin{DoxyEnumerate}
\item \hyperlink{index_file_layout_sec}{File layout} 
\item \hyperlink{index_building_sec}{Building and modifying the system} 
\begin{DoxyEnumerate}
\item \hyperlink{index_prereq_sec}{Prerequisites} 
\item \hyperlink{index_commands_sec}{Executing a build} 
\item \hyperlink{index_modify_run_main_sec}{Modifying and running main} 
\item \hyperlink{index_documentation_sec}{Rebuilding the documentation} 
\end{DoxyEnumerate}
\item \hyperlink{index_api_sec}{Badger\-D\-B A\-P\-I} 
\begin{DoxyEnumerate}
\item \hyperlink{index_storage_sec}{File storage} 
\begin{DoxyEnumerate}
\item \hyperlink{index_file_management_sec}{Creating, opening, and deleting files} 
\item \hyperlink{index_file_data_sec}{Reading and writing data in a file} 
\item \hyperlink{index_page_sec}{Reading and writing data in a page} 
\end{DoxyEnumerate}
\end{DoxyEnumerate}
\end{DoxyEnumerate}\hypertarget{index_file_layout_sec}{}\section{File layout}\label{index_file_layout_sec}
The files in this package are organized under the following hierarchy\-: 
\begin{DoxyPre}
docs/                  generated documentation
src/                   code for BadgerDB
\end{DoxyPre}


You will likely be most interested in {\ttfamily src}\hypertarget{index_building_sec}{}\section{Building and modifying the system}\label{index_building_sec}
\hypertarget{index_prereq_sec}{}\subsection{Prerequisites}\label{index_prereq_sec}
To build and run the system, you need the following packages\-: 
\begin{DoxyItemize}
\item A modern C++ compiler (G\-C\-C $>$= 4.\-6, any recent version of clang) 
\item Doxygen 1.\-6 or higher (for generating documentation only) 
\end{DoxyItemize}

The build system is configured to work on C\-S\-L Red\-Hat 5 and 6 machines out of the box.\hypertarget{index_commands_sec}{}\subsection{Executing a build}\label{index_commands_sec}
All command examples are meant to be run at the command prompt from the {\ttfamily badgerdb} directory. When executing a command, omit the {\ttfamily \$} prompt (so ``{\ttfamily \$ make}'' means you just type ``{\ttfamily make}'' and press enter).

To build the executable\-: 
\begin{DoxyCode}
$ make
\end{DoxyCode}
\hypertarget{index_modify_run_main_sec}{}\subsection{Modifying and running main}\label{index_modify_run_main_sec}
To run the executable, first build the code, then run\-: 
\begin{DoxyCode}
$ ./src/badgerdb\_main
\end{DoxyCode}


If you want to edit what {\ttfamily badgerdb\-\_\-main} does, edit {\ttfamily src/main.\-cpp}.\hypertarget{index_documentation_sec}{}\subsection{Rebuilding the documentation}\label{index_documentation_sec}
Documentation is generated by using Doxygen. If you have updated the documentation and need to regenerate the output files, run\-: 
\begin{DoxyCode}
$ make doc
\end{DoxyCode}
 Resulting documentation will be placed in the {\ttfamily docs/} directory; open {\ttfamily index.\-html} with your web browser to view it.\hypertarget{index_api_sec}{}\section{Badger\-D\-B A\-P\-I}\label{index_api_sec}
\hypertarget{index_storage_sec}{}\subsection{File storage}\label{index_storage_sec}
Interaction with the underlying filesystem is handled by two classes\-: File and Page. Files store zero or more fixed-\/length pages; each page holds zero or more variable-\/length records.

Record data is represented using std\-::strings of arbitrary characters.\hypertarget{index_file_management_sec}{}\subsubsection{Creating, opening, and deleting files}\label{index_file_management_sec}
Files must first be created before they can be used\-: 
\begin{DoxyCode}
\textcolor{comment}{// Create and open a new file with the name "filename.db".}
\hyperlink{classbadgerdb_1_1File}{badgerdb::File} new\_file = \hyperlink{classbadgerdb_1_1File_a1fb708b45103a606f189850d6bf83a0c}{badgerdb::File::create}(\textcolor{stringliteral}{"filename.db"});
\end{DoxyCode}


If you want to open an existing file, use File\-::open like so\-: 
\begin{DoxyCode}
\textcolor{comment}{// Open an existing file with the name "filename.db".}
\hyperlink{classbadgerdb_1_1File}{badgerdb::File} existing\_file = \hyperlink{classbadgerdb_1_1File_a8462afdbd250c0a483ddfbde144c8732}{badgerdb::File::open}(\textcolor{stringliteral}{"filename.db"});
\end{DoxyCode}


Multiple File objects share the same stream to the underlying file. The stream will be automatically closed when the last File object is out of scope; no explicit close command is necessary.

You can delete a file with File\-::remove\-: 
\begin{DoxyCode}
\textcolor{comment}{// Delete a file with the name "filename.db".}
\hyperlink{classbadgerdb_1_1File_a1cc69467366badbd68021ac76a91190e}{badgerdb::File::remove}(\textcolor{stringliteral}{"filename.db"});
\end{DoxyCode}
\hypertarget{index_file_data_sec}{}\subsubsection{Reading and writing data in a file}\label{index_file_data_sec}
Data is added to a File by first allocating a Page, populating it with data, and then writing the Page back to the File.

For example\-: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "file.h"}

...

\textcolor{comment}{// Write a record with the value "hello, world!" to the file.}
badgerdb::File db\_file = \hyperlink{classbadgerdb_1_1File_a8462afdbd250c0a483ddfbde144c8732}{badgerdb::File::open}(\textcolor{stringliteral}{"filename.db"});
\hyperlink{classbadgerdb_1_1Page}{badgerdb::Page} new\_page = db\_file.allocatePage();
new\_page.\hyperlink{classbadgerdb_1_1Page_ad0b1e85fe7849fb767dd8c21a8053cf4}{insertRecord}(\textcolor{stringliteral}{"hello, world!"});
db\_file.writePage(new\_page);
\end{DoxyCode}


Pages are read back from a File using their page numbers\-: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "file.h"}
\textcolor{preprocessor}{#include "page.h"}

...

\textcolor{comment}{// Allocate a page and then read it back.}
badgerdb::Page new\_page = db\_file.allocatePage();
db\_file.writePage(new\_page);
\textcolor{keyword}{const} \hyperlink{namespacebadgerdb_a1f49e404293bf4240756b89b53b1587a}{badgerdb::PageId}& page\_number = new\_page.\hyperlink{classbadgerdb_1_1Page_af55a0b44876bff4d513bdbed8bc8c5a3}{page\_number}();
\hyperlink{classbadgerdb_1_1Page}{badgerdb::Page} same\_page = db\_file.readPage(page\_number);
\end{DoxyCode}


You can also iterate through all pages in the File\-: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "file\_iterator.h"}

...

for (\hyperlink{classbadgerdb_1_1FileIterator}{badgerdb::FileIterator} iter = db\_file.begin();
     iter != db\_file.end();
     ++iter) \{
  std::cout << \textcolor{stringliteral}{"Read page: "} << iter->page\_number() << std::endl;
\}
\end{DoxyCode}
\hypertarget{index_page_sec}{}\subsubsection{Reading and writing data in a page}\label{index_page_sec}
Pages hold variable-\/length records containing arbitrary data.

To insert data on a page\-: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "page.h"}

...

badgerdb::Page new\_page;
new\_page.\hyperlink{classbadgerdb_1_1Page_ad0b1e85fe7849fb767dd8c21a8053cf4}{insertRecord}(\textcolor{stringliteral}{"hello, world!"});
\end{DoxyCode}


Data is read by using Record\-Ids, which are provided when data is inserted\-: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "page.h"}

...

badgerdb::Page new\_page;
\textcolor{keyword}{const} \hyperlink{structbadgerdb_1_1RecordId}{badgerdb::RecordId}& rid = new\_page.\hyperlink{classbadgerdb_1_1Page_ad0b1e85fe7849fb767dd8c21a8053cf4}{insertRecord}(\textcolor{stringliteral}{"hello, world!"});
new\_page.\hyperlink{classbadgerdb_1_1Page_a77b352920c3e66384317bbcdcd900d99}{getRecord}(rid); \textcolor{comment}{// returns "hello, world!"}
\end{DoxyCode}


As Pages use std\-::string to represent data, it's very natural to insert strings; however, any data can be stored\-: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "page.h"}

...

struct Point \{
  \textcolor{keywordtype}{int} x;
  \textcolor{keywordtype}{int} y;
\};
Point new\_point = \{10, -5\};
\hyperlink{classbadgerdb_1_1Page}{badgerdb::Page} new\_page;
std::string new\_data(reinterpret\_cast<char*>(&new\_point),
                     \textcolor{keyword}{sizeof}(new\_point));
\textcolor{keyword}{const} \hyperlink{structbadgerdb_1_1RecordId}{badgerdb::RecordId}& rid = new\_page.\hyperlink{classbadgerdb_1_1Page_ad0b1e85fe7849fb767dd8c21a8053cf4}{insertRecord}(new\_data);
Point read\_point =
    *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }Point*\textcolor{keyword}{>}(new\_page.\hyperlink{classbadgerdb_1_1Page_a77b352920c3e66384317bbcdcd900d99}{getRecord}(rid).data());
\end{DoxyCode}
 Note that serializing structures like this is not industrial strength; it's better to use something like Google's protocol buffers or Boost serialization.

You can also iterate through all records in the Page\-: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "page\_iterator.h"}

...

for (\hyperlink{classbadgerdb_1_1PageIterator}{badgerdb::PageIterator} iter = new\_page.\hyperlink{classbadgerdb_1_1Page_aa0fdb281074cd60cb1f1d6ea6d620772}{begin}();
     iter != new\_page.\hyperlink{classbadgerdb_1_1Page_a8e78cba69bef682a5427932485da4608}{end}();
     ++iter) \{
  std::cout << \textcolor{stringliteral}{"Record data: "} << *iter << std::endl;
\}
\end{DoxyCode}
 